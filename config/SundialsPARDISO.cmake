# -----------------------------------------------------------------
# Programmer:  Raymond Langer @ RWTH Aachen University,
#                               Institute for Combustion Technology
# -----------------------------------------------------------------
# ---------------------------------------------------------------
# PARDISO tests for SUNDIALS CMake-based configuration.

### This is only set if running GUI - simply return first time enabled
IF(PARDISO_DISABLED)
  SET(PARDISO_DISABLED FALSE CACHE INTERNAL "GUI - PARDISO now enabled" FORCE)
  RETURN()
ENDIF()

if(MKL_PARDISO)
  find_package(Pardiso REQUIRED)
else(MKL_PARDISO)
  include(DownloadPardiso)
endif(MKL_PARDISO)

set(PARDISOTest_DIR ${PROJECT_BINARY_DIR}/PARDISOTest)
file(MAKE_DIRECTORY ${PARDISOTest_DIR})

if(MKL_PARDISO)
# Create a CMakeLists.txt file 
file(WRITE ${PARDISOTest_DIR}/CMakeLists.txt
    "cmake_minimum_required(VERSION 3.9)\n"  
    "SET(ENV{CC} \"${CMAKE_C_COMPILER}\")\n"
    "SET(ENV{LDFLAGS} \"${CMAKE_SHARED_LINKER_FLAGS}\")\n"
    "PROJECT(ltest C)\n"
    "SET(CMAKE_VERBOSE_MAKEFILE ON)\n"
    "SET(CMAKE_BUILD_TYPE \"${CMAKE_BUILD_TYPE}\")\n"
    "SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS}\")\n"
    "SET(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE}\")\n"
    "SET(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG}\")\n"
    "SET(CMAKE_C_FLAGS_RELWITHDEBUGINFO \"${CMAKE_C_FLAGS_RELWITHDEBUGINFO}\")\n"
    "SET(CMAKE_C_FLAGS_MINSIZE \"${CMAKE_C_FLAGS_MINSIZE}\")\n"
    "if (POLICY CMP0012)\n"
    "  cmake_policy(SET CMP0012 NEW)\n"
    "endif ()\n"
    "if(POLICY CMP0054)\n"
    "  cmake_policy(SET CMP0054 NEW)\n"
    "endif()\n"
    "\n"
    "if(COMMAND cmake_policy)\n"
    "  cmake_policy(SET CMP0003 NEW)\n"
    "endif(COMMAND cmake_policy)\n"
    "ADD_EXECUTABLE(ltest ltest.c)\n"
    "\n"
    "SET(CMAKE_MODULE_PATH \"${PROJECT_SOURCE_DIR}/config\")\n"
    "include(utilities)\n"
    "find_blas_lapack_mkl_preferred(\"${BLA_VENDOR}\" \"${INTEL_MKL_DIR}\" \"${SEQ_LAPACK}\" \"sundials_mkl_pardiso\")\n"
    "if(INTEL_MKL_DIR OR MKL_INCLUDE_DIR)\n"
    "  if(EXISTS \"${MKL_INCLUDE_DIR}\")\n"
    "    target_include_directories(\n"
    "      ltest\n"
    "      PUBLIC \"\$<INSTALL_INTERFACE:${MKL_INCLUDE_DIR}>\"\n"
    "      PUBLIC \"\$<BUILD_INTERFACE:${MKL_INCLUDE_DIR}>\")\n"
    "  endif()\n"
    "endif()\n"
    "TARGET_LINK_LIBRARIES(ltest  \"${PARDISO_LIBRARIES}\")\n"
    "if(UNIX)\n"
    "  target_link_libraries(ltest \"-lm\")\n"
    "endif()\n"
    "target_compile_definitions(ltest PUBLIC -DMKL_PARDISO)\n"
    "\n"
    "add_custom_target(ltest_run\n"
    "              COMMAND OMP_NUM_THREADS=1 PARDISO_LIC_PATH=\"${PARDISO_DIR}\" ./ltest\n"
    "              DEPENDS ltest\n"
    "              WORKING_DIRECTORY \"\${CMAKE_CURRENT_BINARY_DIR}\")\n"
    )
else()
# Create a CMakeLists.txt file 
file(WRITE ${PARDISOTest_DIR}/CMakeLists.txt
    "cmake_minimum_required(VERSION 3.9)\n"
    "SET(ENV{CC} \"${CMAKE_C_COMPILER}\")\n"
    "SET(ENV{LDFLAGS} \"${CMAKE_SHARED_LINKER_FLAGS}\")\n"
    "PROJECT(ltest C)\n"
    "SET(CMAKE_VERBOSE_MAKEFILE ON)\n"
    "SET(CMAKE_BUILD_TYPE \"${CMAKE_BUILD_TYPE}\")\n"
    "SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS}\")\n"
    "SET(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE}\")\n"
    "SET(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG}\")\n"
    "SET(CMAKE_C_FLAGS_RELWITHDEBUGINFO \"${CMAKE_C_FLAGS_RELWITHDEBUGINFO}\")\n"
    "SET(CMAKE_C_FLAGS_MINSIZE \"${CMAKE_C_FLAGS_MINSIZE}\")\n"
    "if (POLICY CMP0012)\n"
    "  cmake_policy(SET CMP0012 NEW)\n"
    "endif ()\n"
    "if(POLICY CMP0054)\n"
    "  cmake_policy(SET CMP0054 NEW)\n"
    "endif()\n"
    "\n"
    "find_package(OpenMP REQUIRED)\n"
    "\n"
    "if(COMMAND cmake_policy)\n"
    "  cmake_policy(SET CMP0003 NEW)\n"
    "endif(COMMAND cmake_policy)\n"
    "ADD_EXECUTABLE(ltest ltest.c)\n"
    "TARGET_LINK_LIBRARIES(ltest \"${PARDISO_DIR}/${PARDISO_NAME}\" \"${PARDISO_LIBRARIES}\")\n"
    "TARGET_LINK_LIBRARIES(ltest OpenMP::OpenMP_C)\n"
    "if(UNIX)\n"
    "  target_link_libraries(ltest \"-lm\")\n"
    "endif()\n"
    "\n"
    "add_custom_target(ltest_run\n"
    "              COMMAND OMP_NUM_THREADS=1 PARDISO_LIC_PATH=\"${PARDISO_DIR}\" ./ltest\n"
    "              DEPENDS ltest\n"
    "              WORKING_DIRECTORY \"\${CMAKE_CURRENT_BINARY_DIR}\")\n"
    )
endif(MKL_PARDISO)

if(MKL_PARDISO)
# Create a C source file which calls a couple PARDISO functions
  file(WRITE ${PARDISOTest_DIR}/ltest.c
"\#include <stdio.h>\n"
"\#include <stdlib.h>\n"
"\#include <math.h>\n"
"\n"
"\#include \"mkl_pardiso.h\"\n"
"\#include \"mkl_types.h\"\n"
"\#include \"mkl_spblas.h\"\n"
"\n"
"MKL_INT main (void)\n"
"{\n"
"    MKL_INT n = 5;\n"
"    MKL_INT ia[6] = { 1, 4, 7, 9, 12, 14};\n"
"    MKL_INT ja[13] = \n"
"    { 1, 2,    4,\n"
"      1, 2,       5,\n"
"            3, 4,\n"
"      1,    3, 4,\n"
"            3,    5\n"
"    };\n"
"    double a[13] = \n"
"    { 1.0,-2.0,     -4.0,\n"
"     -1.0, 5.0,           8.0,\n"
"                4.0, 2.0,\n"
"               -3.0, 6.0, 7.0,\n"
"      4.0,     -5.0\n"
"    };\n"
"    MKL_INT mtype = 11;       /* Real unsymmetric matrix */\n"
"    struct matrix_descr descrA;\n"
"    sparse_matrix_t       csrA;\n"
"    double b[5], x[5], bs[5], res, res0;\n"
"    MKL_INT nrhs = 1;     /* Number of right hand sides. */\n"
"    void *pt[64];\n"
"    MKL_INT iparm[64];\n"
"    MKL_INT maxfct, mnum, phase, error, msglvl;\n"
"    MKL_INT i, j;\n"
"    double ddum;          /* Double dummy */\n"
"    MKL_INT idum;         /* Integer dummy. */\n"
"    for ( i = 0; i < 64; i++ )\n"
"    {\n"
"        iparm[i] = 0;\n"
"    }\n"
"    iparm[0] = 1;         /* No solver default */\n"
"    iparm[1] = 2;         /* Fill-in reordering from METIS */\n"
"    iparm[3] = 0;         /* No iterative-direct algorithm */\n"
"    iparm[4] = 0;         /* No user fill-in reducing permutation */\n"
"    iparm[5] = 0;         /* Write solution into x */\n"
"    iparm[6] = 0;         /* Not in use */\n"
"    iparm[7] = 2;         /* Max numbers of iterative refinement steps */\n"
"    iparm[8] = 0;         /* Not in use */\n"
"    iparm[9] = 13;        /* Perturb the pivot elements with 1E-13 */\n"
"    iparm[10] = 1;        /* Use nonsymmetric permutation and scaling MPS */\n"
"    iparm[11] = 0;        /* Conjugate/transpose solve */\n"
"    iparm[12] = 1;        /* Maximum weighted matching algorithm is switched-on (default for non-symmetric) */\n"
"    iparm[13] = 0;        /* Output: Number of perturbed pivots */\n"
"    iparm[14] = 0;        /* Not in use */\n"
"    iparm[15] = 0;        /* Not in use */\n"
"    iparm[16] = 0;        /* Not in use */\n"
"    iparm[17] = -1;       /* Output: Number of nonzeros in the factor LU */\n"
"    iparm[18] = -1;       /* Output: Mflops for LU factorization */\n"
"    iparm[19] = 0;        /* Output: Numbers of CG Iterations */\n"
"    maxfct = 1;           /* Maximum number of numerical factorizations. */\n"
"    mnum = 1;             /* Which factorization to use. */\n"
"    msglvl = 0;           /* Print statistical information  */\n"
"    error = 0;            /* Initialize error flag */\n"
"    for ( i = 0; i < 64; i++ )\n"
"    {\n"
"        pt[i] = 0;\n"
"    }\n"
"    phase = 11;\n"
"    PARDISO (pt, &maxfct, &mnum, &mtype, &phase,\n"
"             &n, a, ia, ja, &idum, &nrhs, iparm, &msglvl, &ddum, &ddum, &error);\n"
"    if ( error != 0 )\n"
"    {\n"
"        printf (\"\\nERROR during symbolic factorization: %d\", error);\n"
"        exit (1);\n"
"    }\n"
"    phase = 22;\n"
"    PARDISO (pt, &maxfct, &mnum, &mtype, &phase,\n"
"             &n, a, ia, ja, &idum, &nrhs, iparm, &msglvl, &ddum, &ddum, &error);\n"
"    if ( error != 0 )\n"
"    {\n"
"        printf (\"\\nERROR during numerical factorization: %d\", error);\n"
"        exit (2);\n"
"    }\n"
"    printf (\"\\nFactorization completed ... \");\n"
"    phase = 33;\n"
"\n"
"  descrA.type = SPARSE_MATRIX_TYPE_GENERAL;\n"
"  descrA.mode = SPARSE_FILL_MODE_UPPER;\n"
"  descrA.diag = SPARSE_DIAG_NON_UNIT;\n"
"  mkl_sparse_d_create_csr ( &csrA, SPARSE_INDEX_BASE_ONE, n, n, ia, ia+1, ja, a );\n"
"\n"
"    /* Set right hand side to one. */\n"
"    for ( i = 0; i < n; i++ )\n"
"    {\n"
"        b[i] = 1;\n"
"    }\n"
"\n"
"    iparm[11] = 2;\n"
"    printf (\"\\n\\nSolving the system in CSC format...\\n\");\n"
"    PARDISO (pt, &maxfct, &mnum, &mtype, &phase,\n"
"             &n, a, ia, ja, &idum, &nrhs, iparm, &msglvl, b, x, &error);\n"
"    if ( error != 0 )\n"
"    {\n"
"        printf (\"\\nERROR during solution: %d\", error);\n"
"        exit (3);\n"
"    }\n"
"\n"
"    printf (\"\\nThe solution of the system is: \");\n"
"    for ( j = 0; j < n; j++ )\n"
"    {\n"
"        printf (\"\\n x [%d] = % f\", j, x[j]);\n"
"    }\n"
"    printf (\"\\n\");\n"
"    // Compute residual\n"
"    // the CSC format for A is the CSR format for A transposed\n"
"      mkl_sparse_d_mv( SPARSE_OPERATION_TRANSPOSE, 1.0, csrA, descrA, x, 0.0, bs);\n"
"    res = 0.0;\n"
"    res0 = 0.0;\n"
"    for ( j = 1; j <= n; j++ )\n"
"    {\n"
"        res += (bs[j - 1] - b[j - 1]) * (bs[j - 1] - b[j - 1]);\n"
"        res0 += b[j - 1] * b[j - 1];\n"
"    }\n"
"    res = sqrt (res) / sqrt (res0);\n"
"    printf (\"\\nRelative residual = %e\\n\", res);\n"
"    // Check residual\n"
"    if ( res > 1e-10 )\n"
"    {\n"
"        printf (\"Error: residual is too high!\\n\");\n"
"        exit (10 + i);\n"
"    }\n"
"    mkl_sparse_destroy(csrA);\n"
"    phase = -1;           /* Release internal memory. */\n"
"    PARDISO (pt, &maxfct, &mnum, &mtype, &phase,\n"
"             &n, &ddum, ia, ja, &idum, &nrhs,\n"
"             iparm, &msglvl, &ddum, &ddum, &error);\n"
"    return 0;\n"
"}\n"
)

else()
# Create a C source file which calls a couple PARDISO functions
  file(WRITE ${PARDISOTest_DIR}/ltest.c
    "\#include <stdio.h>\n"
    "\#include <stdlib.h>\n"
    "\#include <math.h>\n"
    "\n"
    "\n"
    "/* pardiso prototypes */\n"
    "void pardisoinit (void   *, int    *,   int *, int *, double *, int *);\n"
    "void pardiso     (void   *, int    *,   int *, int *,    int *, int *, \n"
    "                  double *, int    *,    int *, int *,   int *, int *,\n"
    "                     int *, double *, double *, int *, double *);\n"
    "void pardiso_chkmatrix  (int *, int *, double *, int *, int *, int *);\n"
    "void pardiso_chkvec     (int *, int *, double *, int *);\n"
    "void pardiso_printstats (int *, int *, double *, int *, int *, int *, double *, int *);\n"
    "\n"
    "\n"
    "int main(){\n"
    "/* Matrix data. */\n"
    "int    n = 8;\n"
    "int    ia[ 9] = { 0, 4, 7, 9, 11, 12, 15, 17, 20 };\n"
    "int    ja[20] = { 0,    2,       5, 6, \n"
    "                     1, 2,    4,\n"
    "                        2,             7,\n"
    "                           3,       6,\n"
    "                     1,\n"
    "                        2,       5,    7,\n"
    "                     1,             6,\n"
    "                        2,          6, 7 };\n"
    "double  a[20] = { 7.0,      1.0,           2.0, 7.0, \n"
    "                      -4.0, 8.0,      2.0,\n"
    "                            1.0,                     5.0,\n"
    "                                 7.0,           9.0,\n"
    "                      -4.0,\n"
    "                            7.0,           3.0,      8.0,\n"
    "                       1.0,                    11.0,\n"
    "                           -3.0,                2.0, 5.0 };\n"
    "\n"
    "int      nnz = ia[n];\n"
    "int      mtype = 11;        /* Real unsymmetric matrix */\n"
    "\n"
    "/* RHS and solution vectors. */\n"
    "double   b[8], x[8];\n"
    "int      nrhs = 1;          /* Number of right hand sides. */\n"
    "    void    *pt[64];\n"
    "\n"
    "    /* Pardiso control parameters. */\n"
    "    int      iparm[64];\n"
    "    double   dparm[64];\n"
    "    int      solver;\n"
    "    int      maxfct, mnum, phase, error, msglvl;\n"
    "\n"
    "    /* Number of processors. */\n"
    "    int      num_procs;\n"
    "\n"
    "    /* Auxiliary variables. */\n"
    "    char    *var;\n"
    "    int      i;\n"
    "\n"
    "    double   ddum;              /* Double dummy */\n"
    "    int      idum;              /* Integer dummy. */\n"
    "\n"
    "/* -------------------------------------------------------------------- */\n"
    "/* ..  Setup Pardiso control parameters and initialize the solvers      */\n"
    "/*     internal adress pointers. This is only necessary for the FIRST   */\n"
    "/*     call of the PARDISO solver.                                      */\n"
    "/* ---------------------------------------------------------------------*/\n"
    "      \n"
    "    error = 0;\n"
    "    solver = 0; /* use sparse direct solver */\n"
    "#ifdef MKL_PARDISO\n"
    "for (int i = 0; i < 64; ++i)\n"
    "      pt[i] = 0;\n"
    "#else\n"
    "pardisoinit (pt,  &mtype, &solver, iparm, dparm, &error);\n"
    "\n"
    "    if (error != 0)\n"
    "    {\n"
    "        if (error == -10 )\n"
    "           printf(\"No license file found \\n\");\n"
    "        if (error == -11 )\n"
    "           printf(\"License is expired \\n\");\n"
    "        if (error == -12 )\n"
    "           printf(\"Wrong username or hostname \\n\");\n"
    "         return 1;\n"
    "    }\n"
    "    else\n"
    "        printf(\"[PARDISO]: License check was successful ... \\n\");\n"
    "#endif\n"
    " \n"
    "\n"
    "    /* Numbers of processors, value of OMP_NUM_THREADS */\n"
    "    var = getenv(\"OMP_NUM_THREADS\");\n"
    "    if(var != NULL)\n"
    "        sscanf( var, \"%d\", &num_procs );\n"
    "    else {\n"
    "        num_procs = 1;\n"
    "        printf(\"Set environment OMP_NUM_THREADS to 1\\n\");\n"
    "    }\n"
    "    iparm[2]  = num_procs;\n"
    "   \n"
    "    \n"
    "    maxfct = 1;         /* Maximum number of numerical factorizations.  */\n"
    "    mnum   = 1;         /* Which factorization to use. */\n"
    "    \n"
    "    msglvl = 1;         /* Print statistical information  */\n"
    "    error  = 0;         /* Initialize error flag */\n"
    "\n"
    "\n"
    "/* -------------------------------------------------------------------- */    \n"
    "/* ..  Convert matrix from 0-based C-notation to Fortran 1-based        */\n"
    "/*     notation.                                                        */\n"
    "/* -------------------------------------------------------------------- */ \n"
    "    for (i = 0; i < n+1; i++) {\n"
    "        ia[i] += 1;\n"
    "    }\n"
    "    for (i = 0; i < nnz; i++) {\n"
    "        ja[i] += 1;\n"
    "    }\n"
    "\n"
    "    /* Set right hand side to one. */\n"
    "    for (i = 0; i < n; i++) {\n"
    "        b[i] = i;\n"
    "    }\n"
    "\n"
    "#ifndef MKL_PARDISO\n"
    "/* -------------------------------------------------------------------- */\n"
    "/*  .. pardiso_chkmatrix(...)                                          */\n"
    "/*     Checks the consistency of the given matrix.                      */\n"
    "/*     Use this functionality only for debugging purposes               */\n"
    "/* -------------------------------------------------------------------- */\n"
    "    \n"
    "    pardiso_chkmatrix  (&mtype, &n, a, ia, ja, &error);\n"
    "    if (error != 0) {\n"
    "        printf(\"\\nERROR in consistency of matrix: %d\", error);\n"
    "        exit(1);\n"
    "    }\n"
    "\n"
    "/* -------------------------------------------------------------------- */\n"
    "/* ..  pardiso_chkvec(...)                                              */\n"
    "/*     Checks the given vectors for infinite and NaN values             */\n"
    "/*     Input parameters (see PARDISO user manual for a description):    */\n"
    "/*     Use this functionality only for debugging purposes               */\n"
    "/* -------------------------------------------------------------------- */\n"
    "\n"
    "    pardiso_chkvec (&n, &nrhs, b, &error);\n"
    "    if (error != 0) {\n"
    "        printf(\"\\nERROR  in right hand side: %d\", error);\n"
    "        exit(1);\n"
    "    }\n"
    "\n"
    "/* -------------------------------------------------------------------- */\n"
    "/* .. pardiso_printstats(...)                                           */\n"
    "/*    prints information on the matrix to STDOUT.                       */\n"
    "/*    Use this functionality only for debugging purposes                */\n"
    "/* -------------------------------------------------------------------- */\n"
    "\n"
    "    pardiso_printstats (&mtype, &n, a, ia, ja, &nrhs, b, &error);\n"
    "    if (error != 0) {\n"
    "        printf(\"\\nERROR right hand side: %d\", error);\n"
    "        exit(1);\n"
    "    }\n"
    " \n"
    "#endif // MKL_PARDISO\n"
    "/* -------------------------------------------------------------------- */    \n"
    "/* ..  Reordering and Symbolic Factorization.  This step also allocates */\n"
    "/*     all memory that is necessary for the factorization.              */\n"
    "/* -------------------------------------------------------------------- */ \n"
    "    phase = 11; \n"
    "\n"
    "    pardiso (pt, &maxfct, &mnum, &mtype, &phase,\n"
    "             &n, a, ia, ja, &idum, &nrhs,\n"
    "             iparm, &msglvl, &ddum, &ddum, &error\n"
    "#ifndef MKL_PARDISO\n"
    ",  dparm\n"
    "#endif \n"
    "    );\n"
    "    \n"
    "    if (error != 0) {\n"
    "        printf(\"\\nERROR during symbolic factorization: %d\", error);\n"
    "        exit(1);\n"
    "    }\n"
    "    printf(\"\\nReordering completed ... \");\n"
    "    printf(\"\\nNumber of nonzeros in factors  = %d\", iparm[17]);\n"
    "    printf(\"\\nNumber of factorization MFLOPS = %d\", iparm[18]);\n"
    "   \n"
    "/* -------------------------------------------------------------------- */    \n"
    "/* ..  Numerical factorization.                                         */\n"
    "/* -------------------------------------------------------------------- */    \n"
    "    phase = 22;\n"
    "\n"
    "    pardiso (pt, &maxfct, &mnum, &mtype, &phase,\n"
    "             &n, a, ia, ja, &idum, &nrhs,\n"
    "             iparm, &msglvl, &ddum, &ddum, &error, dparm);\n"
    "   \n"
    "    if (error != 0) {\n"
    "        printf(\"\\nERROR during numerical factorization: %d\", error);\n"
    "        exit(2);\n"
    "    }\n"
    "    printf(\"\\nFactorization completed ...\\n \");\n"
    "\n"
    "/* -------------------------------------------------------------------- */    \n"
    "/* ..  Back substitution and iterative refinement.                      */\n"
    "/* -------------------------------------------------------------------- */    \n"
    "    phase = 33;\n"
    "\n"
    "    iparm[7] = 1;       /* Max numbers of iterative refinement steps. */\n"
    "\n"
    "   \n"
    "    pardiso (pt, &maxfct, &mnum, &mtype, &phase,\n"
    "             &n, a, ia, ja, &idum, &nrhs,\n"
    "             iparm, &msglvl, b, x, &error\n"
    "#ifndef MKL_PARDISO\n"
    ",  dparm\n"
    "#endif \n"
    "    );\n"
    "   \n"
    "    if (error != 0) {\n"
    "        printf(\"\\nERROR during solution: %d\", error);\n"
    "        exit(3);\n"
    "    }\n"
    "\n"
    "    printf(\"\\nSolve completed ... \");\n"
    "    printf(\"\\nThe solution of the system is: \");\n"
    "    for (i = 0; i < n; i++) {\n"
    "        printf(\"\\n x [%d] = % f\", i, x[i] );\n"
    "    }\n"
    "    printf (\"\\n\");\n"
    "\n"
    "/* -------------------------------------------------------------------- */\n"
    "/* ..  Back substitution with tranposed matrix A^t x=b                   */\n"
    "/* -------------------------------------------------------------------- */\n"
    "    phase = 33;\n"
    "\n"
    "    iparm[7]  = 1;       /* Max numbers of iterative refinement steps. */\n"
    "    iparm[11] = 1;       /* Solving with transpose matrix. */\n"
    "\n"
    "    /* Set right hand side to one. */\n"
    "    for (i = 0; i < n; i++) {\n"
    "        b[i] = 1;\n"
    "    }\n"
    "  \n"
    "    pardiso (pt, &maxfct, &mnum, &mtype, &phase,\n"
    "             &n, a, ia, ja, &idum, &nrhs,\n"
    "             iparm, &msglvl, b, x, &error\n"
    "#ifndef MKL_PARDISO\n"
    ",  dparm\n"
    "#endif \n"
    "    );\n"
    "  \n"
    "    if (error != 0) {\n"
    "        printf(\"\\nERROR during solution: %d\", error);\n"
    "        exit(3);\n"
    "    }\n"
    "\n"
    "    printf(\"\\nSolve completed ... \");\n"
    "    printf(\"\\nThe solution of the system is: \");\n"
    "    for (i = 0; i < n; i++) {\n"
    "        printf(\"\\n x [%d] = % f\", i, x[i] );\n"
    "    }\n"
    "    printf (\"\\n\");\n"
    "\n"
    "/* -------------------------------------------------------------------- */    \n"
    "/* ..  Convert matrix back to 0-based C-notation.                       */\n"
    "/* -------------------------------------------------------------------- */ \n"
    "    for (i = 0; i < n+1; i++) {\n"
    "        ia[i] -= 1;\n"
    "    }\n"
    "    for (i = 0; i < nnz; i++) {\n"
    "        ja[i] -= 1;\n"
    "    }\n"
    "\n"
    "/* -------------------------------------------------------------------- */    \n"
    "/* ..  Termination and release of memory.                               */\n"
    "/* -------------------------------------------------------------------- */ \n"
    "    phase = -1;                 /* Release internal memory. */\n"
    "\n"
    "    pardiso (pt, &maxfct, &mnum, &mtype, &phase,\n"
    "             &n, &ddum, ia, ja, &idum, &nrhs,\n"
    "             iparm, &msglvl, &ddum, &ddum, &error\n"
    "#ifndef MKL_PARDISO\n"
    ",  dparm\n"
    "#endif \n"
    "    );\n"
    "    printf (\"SUCCESSFULLYSOLVEDLINEARSYSTEM\\n\");\n"
    "return 0;\n"
    "}\n"
  )
endif(MKL_PARDISO)
# Attempt to link the "ltest" executable
try_compile(LTEST_OK ${PARDISOTest_DIR} ${PARDISOTest_DIR} ltest OUTPUT_VARIABLE MY_OUTPUT)
### running ltest with "normal" pardiso requies two environment variables:
# The followiing should set the environment variables to approrpiate values (not tested)
#if(NOT DEFINED ENV{PARDISO_LIC_PATH})
#  set(ENV{PARDISO_LIC_PATH} "${PARDISO_DIR}")
#endif()
#if(NOT DEFINED ENV{OMP_NUM_THREADS})
#  set(ENV{OMP_NUM_THREADS} 1)
#endif()

# To ensure we do not use stuff from the previous attempts, 
# we must remove the CMakeFiles directory.
file(REMOVE_RECURSE ${PARDISOTest_DIR}/CMakeFiles)
# Process test result
if(LTEST_OK)
message(STATUS "Checking if PARDISO works... OK")
set(PARDISO_FOUND TRUE)
else(LTEST_OK)
message(STATUS "Checking if PARDISO works... FAILED")
set(PARDISO_FOUND FALSE)
endif(LTEST_OK)
 
  
